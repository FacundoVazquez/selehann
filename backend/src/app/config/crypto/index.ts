import { randomBytes, pbkdf2, pbkdf2Sync } from 'crypto';

interface CryptoConfig {
  hashBytes: number;
  saltBytes: number;
  iterations: number;
  digest: 'sha512' | 'whirlpool';
  encoding: 'base64' | 'binary' | 'hex' | 'utf8';
}

// larger numbers mean better security, less
const config = {
  // size of the generated hash
  hashBytes: 32,
  // larger salt means hashed passwords are more resistant to rainbow table, but
  // you get diminishing returns pretty fast
  saltBytes: 16,
  // more iterations means an attacker has to take longer to brute force an
  // individual password, so larger is better. however, larger also means longer
  // to hash the password. tune so that hashing the password takes about a
  // second
  iterations: 10000,
  // A selected HMAC digest algorithm specified by digest is applied to derive
  // a key of the requested byte length (keylen) from the password, salt and
  // iterations.
  // - sha512, sha256
  // - whirlpool
  // and more.
  digest: 'sha512',
  encoding: 'base64',
} as CryptoConfig;

/**
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained buffer which can be arbitrarily encoded for storage
 * that contains all the data needed to verify a password.
 *
 * @param {!String} password
 * password.
 * @param {!function(?Error, ?String, ?String)} callback
 * returns error or hash and salt.
 */
export function hashPasswordAsync(password: string, callback: (error: Error, hash?: string, salt?: string) => any) {
  // generate a salt for pbkdf2
  randomBytes(config.saltBytes, (error, salt) => {
    if (error) return callback(error);

    // Password-Based Key Derivation Function 2
    pbkdf2(password, salt, config.iterations, config.hashBytes, config.digest, (error, hash) => {
      if (error) return callback(error);

      const encodedHash = hash.toString(config.encoding);
      const encodedSalt = salt.toString(config.encoding);

      //console.log(`hash: ${encodedHash}`);
      //console.log(`salt: ${encodedSalt}`);

      callback(null, encodedHash, encodedSalt);
    });
  });
}

/**
 * Hash a password using Node's synchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained buffer which can be arbitrarily encoded for storage
 * that contains all the data needed to verify a password.
 *
 * @param {!String} password
 * password.
 * @returns
 * hash.
 */
export function hashPassword(password: string) {
  // generate a salt for pbkdf2
  const salt = randomBytes(config.saltBytes);

  // Password-Based Key Derivation Function 2
  const hash = pbkdf2Sync(password, salt, config.iterations, config.hashBytes, config.digest);

  const encodedHash = hash.toString(config.encoding);
  const encodedSalt = salt.toString(config.encoding);

  //console.log(`hash: ${encodedHash}`);
  //console.log(`salt: ${encodedSalt}`);

  return { hash: encodedHash, salt: encodedSalt };
}

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} hashPassword
 * hash password.
 * @param {!String} salt
 * salt.
 * @param {!String} password
 * password.
 * @param {!function(?Error, !boolean)}
 * returns error or true or false.
 */
export function verifyPasswordAsync(hashPassword: string, salt: string, password: string, callback: (error: Error, result: boolean) => any) {
  // Get the buffer from encoded salt.
  const encondedSalt = Buffer.from(salt, config.encoding);

  // Password-Based Key Derivation Function 2
  pbkdf2(password, encondedSalt, config.iterations, config.hashBytes, config.digest, (err, hash) => {
    if (err) return callback(err, false);

    const encodedHash = hash.toString(config.encoding);

    //console.log(`hash: ${encodedHash}`);
    //console.log(`salt: ${salt}`);

    callback(null, hashPassword === encodedHash);
  });
}

/**
 * Verify a password using Node's synchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} hashPassword
 * hash password.
 * @param {!String} salt
 * salt.
 * @param {!String} password
 * password.
 * @returns
 * verification.
 */
export function verifyPassword(hashPassword: string, salt: string, password: string) {
  // Get the buffer from encoded salt.
  const encondedSalt = Buffer.from(salt, config.encoding);

  // Password-Based Key Derivation Function 2
  const hash = pbkdf2Sync(password, encondedSalt, config.iterations, config.hashBytes, config.digest);

  const encodedHash = hash.toString(config.encoding);

  //console.log(`hash: ${encodedHash}`);
  //console.log(`salt: ${salt}`);

  return hashPassword === encodedHash;
}
